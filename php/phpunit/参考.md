[文档地址](https://phpunit.readthedocs.io/zh_CN/latest)

[官方文档](http://www.phpunit.cn/manual/7.0/zh_cn/)

#### 简单测试

##### 依赖关系

- ` @depends  method_name`

-  `method_name` 方法返回值作为当前方法传入参数， 可以多个

- ```php
  <?php declare(strict_types=1);
  use PHPUnit\Framework\TestCase;
  
  final class MultipleDependenciesTest extends TestCase
  {
      public function testProducerFirst(): string
      {
          $this->assertTrue(true);
          return 'first';
      }
  
      public function testProducerSecond(): string
      {
          $this->assertTrue(true);
          return 'second';
      }
  
      /**
       * @depends testProducerFirst
       * @depends testProducerSecond
       */
      public function testConsumer(string $a, string $b): void
      {
          $this->assertSame('first', $a);
          $this->assertSame('second', $b);
      }
  ```



##### 数据提供

 - `@dataProvider methodName`

 - 提供数据方法返回结果必须是一个数组， 每个元素也是一个数组；或是返回迭代器

 - 可以 depends  混合使用 ，或者多个一起用

 - ```php
   <?php
   
   namespace framework\tests\test;
   
   use Iterator;
   use PHPUnit\Framework\TestCase;
   
   class DataProviderTest extends TestCase
   {
       /**
        * Undocumented function
        *
        * @dataProvider sumProvider
        * @param integer $a
        * @param integer $b
        * @param int $sum
        * @return void
        */
       public function testSum(int $a, int $b, int $sum)
       {       
           $this->assertEquals($a + $b, $sum);
       }
   
       public function sumProvider()
       {   
           return [
               'one' => [1, 1, 2],
               'one2' => [7, 1, 8],
               'one3' => [6, 12, 18],
           ];
       }
   
       /**
        * 迭代器数据提供
        *
        * @dataProvider subProvider
        * @param integer $a
        * @param integer $b
        * @param integer $ret
        * @return void
        */
       public function testSub(int $a, int $b, int $ret)
       {
           $this->assertEquals($a - $b, $ret);
       }
   
       public function subProvider()
       {   
           return new arrayI();
       }
   
       /**
        * depends  dataProvider 混合使用
        *
        * @depends test3Denpends
        * @dataProvider test3Provider
        * @return void
        */
       public function test3()
       {
           if (func_get_arg(0) == 'one') {
               $this->assertEquals(['one', 'depends'], func_get_args());
           } else {
               $this->assertEquals(['two', 'depends'], func_get_args());
           }
           
       }
   
       public function test3Denpends()
       {
           return 'depends';
       }
   
       public function test3Provider()
       {
           return [['one'],['two']];
       }
   }
   
   class arrayI implements Iterator
   {
       private $prosition = 0;
       private $arr = [
           [2, 1, 1],
           [7, 8, -1]
       ];
   
       public function current ( )
       {
           return $this->arr[$this->prosition];
       }
       public function key ( )
       {
           return $this->prosition;
       }
       public function next ( )
       {
           $this->prosition += 1;
       }
   
       public function rewind ( )
       {
           $this->prosition = 0;
       }
   
       public function valid ( )
       {
           return $this->prosition >= count($this->arr) ? false : true;
       }
   }
   ```

###### tips

> 所有数据供给器方法的执行都是在对 `setUpBeforeClass()` 静态方法的调用和第一次对 `setUp()` 方法的调用之前完成的。因此，无法在数据供给器中使用创建于这两个方法内的变量。这是必须的，这样 PHPUnit 才能计算测试的总数量。



##### 异常测试

- 对异常进行预期判断

- `expectException()、 expectExceptionMessage()、 expectExceptionCod()`

- ```php
  <?php
  namespace framework\tests\test;
  
  use InvalidArgumentException;
  use PHPUnit\Framework\TestCase;
  
  class ExceptionTest extends TestCase
  {
      public function testOne()
      {
          $this->expectException(InvalidArgumentException::class);
          $this->expectExceptionMessage('test throw exception');
          $this->expectExceptionCode(111);
          throw new InvalidArgumentException('test throw exception', 111);
      }
  }
  ```

##### 对于错误\警告\通知测试

 - ```php
   <?php
   namespace framework\tests\test;
   
   use PHPUnit\Framework\TestCase;
   
   class ErrorTest extends TestCase
   {
       public function testWarning()
       {
           $this->expectWarning();
           $this->expectWarningMessage('warning');
           trigger_error('warning', E_USER_WARNING);
       }
   
       public function testError()
       {
           $this->expectError();
           $this->expectErrorMessage('error');
           trigger_error('error', E_USER_ERROR);
       }
   
       public function testNotice()
       {
           $this->expectNotice();
           $this->expectNoticeMessage('notice');
           trigger_error('notice', E_USER_NOTICE);
       }
   }
   
   ```

	- > PHP 的 `error_reporting` 运行时配置会对 PHPUnit 将哪些错误转换为异常有所限制。如果在这个特性上碰到问题，请确认 PHP 的配置中没有抑制你所关注的错误类型。

##### 对输出进行判断

 - ```php
   <?php
   namespace framework\tests\test;
   
   use PHPUnit\Framework\TestCase;
   
   class OutputTest extends TestCase
   {
       public function testOne()
       {
           $this->expectOutputString('hello tom');
           echo 'hello';
           //规范输出
           $this->setOutputCallback(function ($str) {
               return $str . ' tom';
           });
       }
   }
   ```

 - > | 方法                                                | 含义                                                        |
   > | --------------------------------------------------- | ----------------------------------------------------------- |
   > | `void expectOutputRegex(string $regularExpression)` | 设置输出预期为输出应当匹配正则表达式 `$regularExpression`。 |
   > | `void expectOutputString(string $expectedString)`   | 设置输出预期为输出应当与 `$expectedString` 相等。           |
   > | `bool setOutputCallback(callable $callback)`        | 设置回调函数，用来做诸如将实际输出规范化之类的动作。        |
   > | `string getActualOutput()`                          | 获取实际输出。                                              |
   >
   > 在严格模式下，本身产生输出的测试将会失败。

#### 命令行测试

> # 3. 命令行测试执行器
>
> PHPUnit 命令行测试执行器可通过 `phpunit` 命令调用。下面的代码展示了如何用 PHPUnit 命令行测试执行器来运行测试：
>
> ```
> $ phpunit ArrayTest
> PHPUnit latest.0 by Sebastian Bergmann and contributors.
> 
> ..
> 
> Time: 0 seconds
> 
> OK (2 tests, 2 assertions)
> ```
>
> 上面这个调用例子中，PHPUnit 命令行测试执行器将在当前工作目录中寻找 `ArrayTest.php` 源文件并加载之。而在此源文件中应当能找到 `ArrayTest` 测试用例类，此类中的测试将被执行。
>
> 对于每个测试的运行，PHPUnit 命令行工具输出一个字符来指示进展：
>
> ```
> .
> ```
>
> > 当测试成功时输出。
>
> ```
> F
> ```
>
> > 当测试方法运行过程中一个断言失败时输出。
>
> ```
> E
> ```
>
> > 当测试方法运行过程中产生一个错误时输出。
>
> ```
> R
> ```
>
> > 当测试被标记为有风险时输出（参见[有风险的测试](https://phpunit.readthedocs.io/zh_CN/latest/risky-tests.html#risky-tests)）。
>
> ```
> S
> ```
>
> > 当测试被跳过时输出（参见[未完成的测试与跳过的测试](https://phpunit.readthedocs.io/zh_CN/latest/incomplete-and-skipped-tests.html#incomplete-and-skipped-tests)）。
>
> ```
> I
> ```
>
> > 当测试被标记为不完整或未实现时输出（参见[未完成的测试与跳过的测试](https://phpunit.readthedocs.io/zh_CN/latest/incomplete-and-skipped-tests.html#incomplete-and-skipped-tests)）。
>
> PHPUnit 区分*失败（failure）*与*错误（error）*。失败指的是被违背了的 PHPUnit 断言，例如一个失败的 `assertSame()` 调用。错误指的是意料之外的异常（exception）或 PHP 错误。这种差异已被证明在某些时候是非常有用的，因为错误往往比失败更容易修复。如果得到了一个非常长的问题列表，那么最好先对付错误，当错误全部修复了之后再试一次瞧瞧还有没有失败。
>
> 
>
> ## 命令行选项
>
> 让我们来瞧瞧以下代码中命令行测试执行器的各种选项：
>
> ```
> $ phpunit --help
> PHPUnit latest.0 by Sebastian Bergmann and contributors.
> 
> Usage:
>   phpunit [options] UnitTest.php
>   phpunit [options] <directory>
> 
> Code Coverage Options:
>   --coverage-clover <file>    Generate code coverage report in Clover XML format
>   --coverage-crap4j <file>    Generate code coverage report in Crap4J XML format
>   --coverage-html <dir>       Generate code coverage report in HTML format
>   --coverage-php <file>       Export PHP_CodeCoverage object to file
>   --coverage-text <file>      Generate code coverage report in text format [default: standard output]
>   --coverage-xml <dir>        Generate code coverage report in PHPUnit XML format
>   --coverage-cache <dir>      Cache static analysis results
>   --warm-coverage-cache       Warm static analysis cache
>   --coverage-filter <dir>     Include <dir> in code coverage analysis
>   --path-coverage             Perform path coverage analysis
>   --disable-coverage-ignore   Disable annotations for ignoring code coverage
>   --no-coverage               Ignore code coverage configuration
> 
> Logging Options:
>   --log-junit <file>          Log test execution in JUnit XML format to file
>   --log-teamcity <file>       Log test execution in TeamCity format to file
>   --testdox-html <file>       Write agile documentation in HTML format to file
>   --testdox-text <file>       Write agile documentation in Text format to file
>   --testdox-xml <file>        Write agile documentation in XML format to file
>   --reverse-list              Print defects in reverse order
>   --no-logging                Ignore logging configuration
> 
> Test Selection Options:
>   --filter <pattern>          Filter which tests to run
>   --testsuite <name>          Filter which testsuite to run
>   --group <name>              Only runs tests from the specified group(s)
>   --exclude-group <name>      Exclude tests from the specified group(s)
>   --list-groups               List available test groups
>   --list-suites               List available test suites
>   --list-tests                List available tests
>   --list-tests-xml <file>     List available tests in XML format
>   --test-suffix <suffixes>    Only search for test in files with specified suffix(es). Default: Test.php,.phpt
> 
> Test Execution Options:
>   --dont-report-useless-tests Do not report tests that do not test anything
>   --strict-coverage           Be strict about @covers annotation usage
>   --strict-global-state       Be strict about changes to global state
>   --disallow-test-output      Be strict about output during tests
>   --disallow-resource-usage   Be strict about resource usage during small tests
>   --enforce-time-limit        Enforce time limit based on test size
>   --default-time-limit <sec>  Timeout in seconds for tests without @small, @medium or @large
>   --disallow-todo-tests       Disallow @todo-annotated tests
> 
>   --process-isolation         Run each test in a separate PHP process
>   --globals-backup            Backup and restore $GLOBALS for each test
>   --static-backup             Backup and restore static attributes for each test
> 
>   --colors <flag>             Use colors in output ("never", "auto" or "always")
>   --columns <n>               Number of columns to use for progress output
>   --columns max               Use maximum number of columns for progress output
>   --stderr                    Write to STDERR instead of STDOUT
>   --stop-on-defect            Stop execution upon first not-passed test
>   --stop-on-error             Stop execution upon first error
>   --stop-on-failure           Stop execution upon first error or failure
>   --stop-on-warning           Stop execution upon first warning
>   --stop-on-risky             Stop execution upon first risky test
>   --stop-on-skipped           Stop execution upon first skipped test
>   --stop-on-incomplete        Stop execution upon first incomplete test
>   --fail-on-incomplete        Treat incomplete tests as failures
>   --fail-on-risky             Treat risky tests as failures
>   --fail-on-skipped           Treat skipped tests as failures
>   --fail-on-warning           Treat tests with warnings as failures
>   -v|--verbose                Output more verbose information
>   --debug                     Display debugging information
> 
>   --repeat <times>            Runs the test(s) repeatedly
>   --teamcity                  Report test execution progress in TeamCity format
>   --testdox                   Report test execution progress in TestDox format
>   --testdox-group             Only include tests from the specified group(s)
>   --testdox-exclude-group     Exclude tests from the specified group(s)
>   --no-interaction            Disable TestDox progress animation
>   --printer <printer>         TestListener implementation to use
> 
>   --order-by <order>          Run tests in order: default|defects|duration|no-depends|random|reverse|size
>   --random-order-seed <N>     Use a specific random seed <N> for random order
>   --cache-result              Write test results to cache file
>   --do-not-cache-result       Do not write test results to cache file
> 
> Configuration Options:
>   --prepend <file>            A PHP script that is included as early as possible
>   --bootstrap <file>          A PHP script that is included before the tests run
>   -c|--configuration <file>   Read configuration from XML file
>   --no-configuration          Ignore default configuration file (phpunit.xml)
>   --extensions <extensions>   A comma separated list of PHPUnit extensions to load
>   --no-extensions             Do not load PHPUnit extensions
>   --include-path <path(s)>    Prepend PHP's include_path with given path(s)
>   -d <key[=value]>            Sets a php.ini value
>   --cache-result-file <file>  Specify result cache path and filename
>   --generate-configuration    Generate configuration file with suggested settings
>   --migrate-configuration     Migrate configuration file to current format
> 
> Miscellaneous Options:
>   -h|--help                   Prints this usage information
>   --version                   Prints the version and exits
>   --atleast-version <min>     Checks that version is greater than min and exits
>   --check-version             Check whether PHPUnit is the latest version
> phpunit UnitTest
> ```
>
> > 运行由 `UnitTest` 类提供的测试。这个类应当在 `UnitTest.php` 源文件中声明。
> >
> > `UnitTest` 这个类必须满足以下二个条件之一：要么它继承自 `PHPUnit\Framework\TestCase`；要么它提供 `public static suite()` 方法，这个方法返回一个 `PHPUnit\Framework\Test` 对象，比如，一个 `PHPUnit\Framework\TestSuite` 类的实例。
>
> ```
> phpunit UnitTest UnitTest.php
> ```
>
> > 运行由 `UnitTest` 类提供的测试。这个类应当在指定的源文件中声明。
>
> ```
> --coverage-clover
> ```
>
> > 为运行的测试生成带有代码覆盖率信息的 XML 格式的日志文件。更多细节参见[代码覆盖率分析](https://phpunit.readthedocs.io/zh_CN/latest/code-coverage-analysis.html#code-coverage-analysis)。
>
> ```
> --coverage-crap4j
> ```
>
> > 生成 Crap4j 格式的代码覆盖率报告。更多细节请参见[代码覆盖率分析](https://phpunit.readthedocs.io/zh_CN/latest/code-coverage-analysis.html#code-coverage-analysis)。
>
> ```
> --coverage-html
> ```
>
> > 生成 HTML 格式的代码覆盖率报告。更多细节请参见[代码覆盖率分析](https://phpunit.readthedocs.io/zh_CN/latest/code-coverage-analysis.html#code-coverage-analysis)。
>
> ```
> --coverage-php
> ```
>
> > 生成一个序列化后的 PHP_CodeCoverage 对象，此对象含有代码覆盖率信息。
>
> ```
> --coverage-text
> ```
>
> > 为运行的测试以人们可读的格式生成带有代码覆盖率信息的日志文件或命令行输出。
>
> ```
> --log-junit
> ```
>
> > 为运行的测试生成 JUnit XML 格式的日志文件。
>
> ```
> --testdox-html` 和 `--testdox-text
> ```
>
> > 为运行的测试以 HTML 或纯文本格式生成敏捷文档（参见 [TestDox](https://phpunit.readthedocs.io/zh_CN/latest/textui.html#textui-testdox)）。
>
> ```
> --filter
> ```
>
> > 只运行名称与给定模式匹配的测试。如果模式未用定界符包住，PHPUnit 将用 `/` 定界符来将其包住。
> >
> > 测试名称将以以下格式之一进行匹配：
> >
> > ```
> > TestNamespace\TestCaseClass::testMethod
> > ```
> >
> > > 默认的测试名称格式等价于在测试方法内使用 `__METHOD__` 魔术常量。
> >
> > ```
> > TestNamespace\TestCaseClass::testMethod with data set #0
> > ```
> >
> > > 当测试拥有数据供给器时，数据的每轮迭代都会将其当前索引附加在默认测试名称结尾处。
> >
> > ```
> > TestNamespace\TestCaseClass::testMethod with data set "my named data"
> > ```
> >
> > > > 当测试拥有使用命名数据集的数据供给器时，数据的每轮迭代都会将当前名称附加在默认测试名称结尾处。命名数据集的例子参见[示例 3.1](https://phpunit.readthedocs.io/zh_CN/latest/textui.html#textui-examples-testcaseclass-php)。
> > >
> > > 示例 3.1 命名数据集
> > >
> > > ```
> > > <?php
> > > use PHPUnit\Framework\TestCase;
> > > 
> > > namespace TestNamespace;
> > > 
> > > class TestCaseClass extends TestCase
> > > {
> > >     /**
> > >      * @dataProvider provider
> > >      */
> > >     public function testMethod($data)
> > >     {
> > >         $this->assertTrue($data);
> > >     }
> > > 
> > >     public function provider()
> > >     {
> > >         return [
> > >             'my named data' => [true],
> > >             'my data'       => [true]
> > >         ];
> > >     }
> > > }
> > > ```
> >
> > ```
> > /path/to/my/test.phpt
> > ```
> >
> > > 对于 PHPT 测试，其测试名称是文件系统路径。
> >
> > 有效的过滤器模式例子参见[示例 3.2](https://phpunit.readthedocs.io/zh_CN/latest/textui.html#textui-examples-filter-patterns)。
> >
> > 示例 3.2 过滤器模式示例
> >
> > ```
> > --filter 'TestNamespace\\TestCaseClass::testMethod'
> > --filter 'TestNamespace\\TestCaseClass'
> > --filter TestNamespace
> > --filter TestCaseClase
> > --filter testMethod
> > --filter '/::testMethod .*"my named data"/'
> > --filter '/::testMethod .*#5$/'
> > --filter '/::testMethod .*#(5|6|7)$/'
> > ```
> >
> > 在匹配数据供给器时有一些额外的快捷方式，参见[示例 3.3](https://phpunit.readthedocs.io/zh_CN/latest/textui.html#textui-examples-filter-shortcuts)。
> >
> > 示例 3.3 过滤器快捷方式
> >
> > ```
> > --filter 'testMethod#2'
> > --filter 'testMethod#2-4'
> > --filter '#2'
> > --filter '#2-4'
> > --filter 'testMethod@my named data'
> > --filter 'testMethod@my.*data'
> > --filter '@my named data'
> > --filter '@my.*data'
> > ```
>
> ```
> --testsuite
> ```
>
> > 只运行名称与给定模式匹配的测试套件。
>
> ```
> --group
> ```
>
> > 只运行来自指定分组（可以多个）的测试。可以用 `@group` 标注为测试标记其所属的分组。
> >
> > `@author` 和 `@ticket` 标注都是 `@group` 的别名，分别允许基于作者和事务 ID 筛选测试。
>
> ```
> --exclude-group
> ```
>
> > 排除来自指定分组（可以多个）的测试。可以用 `@group` 标注为测试标记其所属的分组。
>
> ```
> --list-groups
> ```
>
> > 列出所有有效的测试分组。
>
> ```
> --test-suffix
> ```
>
> > 只查找文件名以指定后缀（可以多个）结尾的测试文件。
>
> ```
> --dont-report-useless-tests
> ```
>
> > 不报告事实上不测试任何内容的测试。详情参见[有风险的测试](https://phpunit.readthedocs.io/zh_CN/latest/risky-tests.html#risky-tests)。
>
> ```
> --strict-coverage
> ```
>
> > 更严格对待意外的代码覆盖。详情参见[有风险的测试](https://phpunit.readthedocs.io/zh_CN/latest/risky-tests.html#risky-tests)。
>
> ```
> --strict-global-state
> ```
>
> > 更严格对待全局状态篡改。详情参见[有风险的测试](https://phpunit.readthedocs.io/zh_CN/latest/risky-tests.html#risky-tests)。
>
> ```
> --disallow-test-output
> ```
>
> > 更严格对待测试执行期间产生的输出。详情参见[有风险的测试](https://phpunit.readthedocs.io/zh_CN/latest/risky-tests.html#risky-tests)。
>
> ```
> --disallow-todo-tests
> ```
>
> > 不执行文档注释块中含有 `@todo` 标注的测试。
>
> ```
> --enforce-time-limit
> ```
>
> > 根据测试规模对其加上执行时长限制。详情参见[有风险的测试](https://phpunit.readthedocs.io/zh_CN/latest/risky-tests.html#risky-tests)。
>
> ```
> --process-isolation
> ```
>
> > 每个测试都在独立的 PHP 进程中运行。
>
> ```
> --no-globals-backup
> ```
>
> > 不要备份与还原 $GLOBALS。更多细节请参见[全局状态](https://phpunit.readthedocs.io/zh_CN/latest/fixtures.html#fixtures-global-state)。
>
> ```
> --static-backup
> ```
>
> > 备份与还原用户定义的类中的静态属性。更多细节请参见[全局状态](https://phpunit.readthedocs.io/zh_CN/latest/fixtures.html#fixtures-global-state)。
>
> ```
> --colors
> ```
>
> > 使用彩色输出。在 Windows 上，用 [ANSICON](https://github.com/adoxa/ansicon) 或 [ConEmu](https://github.com/Maximus5/ConEmu)。
> >
> > 本选项有三个可能的值：
> >
> > - `never`：完全不使用彩色输出。当未使用 `--colors` 选项时，这是默认值。
> > - `auto`：如果当前终端不支持彩色、或者输出被管道输出至其他命令、或输出被重定向至文件时，不使用彩色输出，其余情况使用彩色。
> > - `always`：总是使用彩色输出，即使当前终端不支持彩色、输出被管道输出至其他命令、或输出被重定向至文件。
> >
> > 当使用了 `--colors` 选项但未指定任何值时，将选择 `auto` 做为其值。
>
> ```
> --columns
> ```
>
> > 定义输出所使用的列数。如果将其值定义为 `max`，则使用当前终端所支持的最大列数。
>
> ```
> --stderr
> ```
>
> > 选择输出到 `STDERR` 而非 `STDOUT`。
>
> ```
> --stop-on-error
> ```
>
> > 首次错误出现后停止执行。
>
> ```
> --stop-on-failure
> ```
>
> > 首次错误或失败出现后停止执行。
>
> ```
> --stop-on-risky
> ```
>
> > 首次碰到有风险的测试时停止执行。
>
> ```
> --stop-on-skipped
> ```
>
> > 首次碰到跳过的测试时停止执行。
>
> ```
> --stop-on-incomplete
> ```
>
> > 首次碰到不完整的测试时停止执行。
>
> ```
> --verbose
> ```
>
> > 输出更详尽的信息，例如不完整或者跳过的测试的名称。
>
> ```
> --debug
> ```
>
> > 输出调试信息，例如当一个测试开始执行时输出其名称。
>
> ```
> --loader
> ```
>
> > 指定要使用的 `PHPUnit\Runner\TestSuiteLoader` 实现。
> >
> > 标准的测试套件加载器将在当前工作目录和 PHP 的 `include_path` 配置指令中指定的每个目录内查找源文件。诸如 `Project_Package_Class` 这样的类名对应的源文件名为 `Project/Package/Class.php`。
>
> ```
> --repeat
> ```
>
> > 将测试重复运行指定次数。
>
> ```
> --testdox
> ```
>
> > 以 TestDox 格式报告测试进度。（参见 [TestDox](https://phpunit.readthedocs.io/zh_CN/latest/textui.html#textui-testdox)）。
>
> ```
> --printer
> ```
>
> > 指定要使用的结果输出器（printer）。输出器类必须扩展 `PHPUnit\Util\Printer` 并且实现 `PHPUnit\Framework\TestListener` 接口。
>
> ```
> --bootstrap
> ```
>
> > 在测试前先运行一个 “bootstrap” PHP 文件。
>
> ```
> --configuration`、`-c
> ```
>
> > 从 XML 文件中读取配置信息。更多细节请参见 [XML 配置文件](https://phpunit.readthedocs.io/zh_CN/latest/configuration.html#appendixes-configuration)。
> >
> > 如果 `phpunit.xml` 或 `phpunit.xml.dist`（按此顺序）存在于当前工作目录并且*未*使用 `--configuration`，将自动从此文件中读取配置。
> >
> > 如果指定了目录且在此目录中存在 `phpunit.xml` 或 `phpunit.xml.dist`（按此顺序）将自动从此文件中读取配置。
>
> ```
> --no-configuration
> ```
>
> > 忽略当前工作目录下的 `phpunit.xml` 与 `phpunit.xml.dist`。
>
> ```
> --include-path
> ```
>
> > 向 PHP 的 include_path 开头添加指定路径（可以多个）。
>
> ```
> -d
> ```
>
> > 设置指定的 PHP 配置选项的值。
>
> 注
>
> 请注意，选项不能放在参数之后。
>
> 
>
> ## TestDox
>
> PHPUnit 的 TestDox 功能着眼于测试类及其所有测试方法的名称，将它们驼峰式大小写（camel case）（或蛇式大小写（snake_case））拼写的 PHP 名称转换为句子：`testBalanceIsInitiallyZero()`（或 `test_balance_is_initially_zero()`）转化为“Balance is initially zero”。如果有多个测试方法的名字互相之间的差异只是一个或多个数字的后缀，例如 `testBalanceCannotBecomeNegative()` 和 `testBalanceCannotBecomeNegative2()`，假如所有这些测试都成功，句子“Balance cannot become negative”只会出现一次。
>
> 来看一下从 `BankAccount` 类生成的敏捷文档：
>
> ```
> $ phpunit --testdox BankAccountTest.php
> PHPUnit latest.0 by Sebastian Bergmann and contributors.
> 
> BankAccount
>  ✔ Balance is initially zero
>  ✔ Balance cannot become negative
> ```
>
> 另外，敏捷文档也能以 HTML 或纯文本格式生成并写入文件中，用 `--testdox-html` 和 `--testdox-text` 参数即可。
>
> 敏捷文档可以用于将对项目所使用的外部包所做出的假设文档化。使用外部包，你就暴露于这个包的行为与你所预期的不同的风险中，并且包的未来版本可能在你所不知道的情况下有微妙的改变并破坏你的代码。每次做出假设时就编写一个对应的测试可以处理这些风险。如果测试成功，那么假设就有效。如果所有的假设都通过测试来文档化，外部包在未来发布新版本就不会引起忧虑：如果测试成功，那么系统就应当能继续正常运作。

#### 基境

> 在编写测试时，最费时的部分之一是编写代码来将整个场景设置成某个已知的状态，并在测试结束后将其复原到初始状态。这个已知的状态称为测试的*基境（fixture）*。
>
> 在[用 PHPUnit 测试数组操作](https://phpunit.readthedocs.io/zh_CN/latest/writing-tests-for-phpunit.html#writing-tests-for-phpunit-examples-stacktest-php)中，基境就是存储在 `$stack` 变量中的数组。然而，绝大多数时候基境均远比一个简单数组要复杂，用于建立基境的代码量也会随之增长。测试的真正内容就被淹没于建立基境带来的干扰中。当编写多个需要类似基境的测试时这个问题就变得更糟糕了。如果没有来自于测试框架的帮助，就不得不在写每一个测试时都将建立基境的代码重复一次。
>
> PHPUnit 支持共享建立基境的代码。在运行某个测试方法前，会调用一个名叫 `setUp()` 的模板方法。`setUp()` 是创建测试所用对象的地方。当测试方法运行结束后，不管是成功还是失败，都会调用另外一个名叫 `tearDown()` 的模板方法。`tearDown()` 是清理测试所用对象的地方。
>
> 在[用 @depends 标注来表示依赖关系](https://phpunit.readthedocs.io/zh_CN/latest/writing-tests-for-phpunit.html#writing-tests-for-phpunit-examples-stacktest2-php)中，我们在测试之间运用生产者-消费者关系来共享基境。这并非总是预期的方式，甚至有时是不可能的。[示例 4.1](https://phpunit.readthedocs.io/zh_CN/latest/fixtures.html#fixtures-examples-stacktest-php) 展示了另外一个编写测试 `StackTest` 的方式。在这个方式中，不再重用基境本身，而是重用建立基境的代码。首先声明一个实例变量，`$stack`，用来替代方法内的局部变量。然后把 `array` 基境的建立放到 `setUp()` 方法中。最后，从测试方法中去除冗余代码，在 `assertSame()` 断言方法中使用新引入的实例变量 `$this->stack` 替代方法内的局部变量 `$stack`。
>
> 示例 4.1 用 setUp() 来创建堆栈基境
>
> ```
> <?php declare(strict_types=1);
> use PHPUnit\Framework\TestCase;
> 
> final class StackTest extends TestCase
> {
>     private $stack;
> 
>     protected function setUp(): void
>     {
>         $this->stack = [];
>     }
> 
>     public function testEmpty(): void
>     {
>         $this->assertTrue(empty($this->stack));
>     }
> 
>     public function testPush(): void
>     {
>         array_push($this->stack, 'foo');
> 
>         $this->assertSame('foo', $this->stack[count($this->stack)-1]);
>         $this->assertFalse(empty($this->stack));
>     }
> 
>     public function testPop(): void
>     {
>         array_push($this->stack, 'foo');
> 
>         $this->assertSame('foo', array_pop($this->stack));
>         $this->assertTrue(empty($this->stack));
>     }
> }
> ```
>
> 测试类的每个测试方法都会运行一次 `setUp()` 和 `tearDown()` 模板方法（同时，每个测试方法都是在一个全新的测试类实例上运行的）。
>
> 另外，`setUpBeforeClass()` 与 `tearDownAfterClass()` 模板方法将分别在测试用例类的第一个测试运行之前和测试用例类的最后一个测试运行之后调用。
>
> 下面这个例子中展示了测试用例类中所有可用的模板方法。
>
> 示例 4.2 展示所有可用模板方法的示例
>
> ```
> <?php declare(strict_types=1);
> use PHPUnit\Framework\TestCase;
> 
> final class TemplateMethodsTest extends TestCase
> {
>     public static function setUpBeforeClass(): void
>     {
>         fwrite(STDOUT, __METHOD__ . "\n");
>     }
> 
>     protected function setUp(): void
>     {
>         fwrite(STDOUT, __METHOD__ . "\n");
>     }
> 
>     protected function assertPreConditions(): void
>     {
>         fwrite(STDOUT, __METHOD__ . "\n");
>     }
> 
>     public function testOne(): void
>     {
>         fwrite(STDOUT, __METHOD__ . "\n");
>         $this->assertTrue(true);
>     }
> 
>     public function testTwo(): void
>     {
>         fwrite(STDOUT, __METHOD__ . "\n");
>         $this->assertTrue(false);
>     }
> 
>     protected function assertPostConditions(): void
>     {
>         fwrite(STDOUT, __METHOD__ . "\n");
>     }
> 
>     protected function tearDown(): void
>     {
>         fwrite(STDOUT, __METHOD__ . "\n");
>     }
> 
>     public static function tearDownAfterClass(): void
>     {
>         fwrite(STDOUT, __METHOD__ . "\n");
>     }
> 
>     protected function onNotSuccessfulTest(Throwable $t): void
>     {
>         fwrite(STDOUT, __METHOD__ . "\n");
>         throw $t;
>     }
> }
> $ phpunit TemplateMethodsTest
> PHPUnit latest.0 by Sebastian Bergmann and contributors.
> 
> TemplateMethodsTest::setUpBeforeClass
> TemplateMethodsTest::setUp
> TemplateMethodsTest::assertPreConditions
> TemplateMethodsTest::testOne
> TemplateMethodsTest::assertPostConditions
> TemplateMethodsTest::tearDown
> .TemplateMethodsTest::setUp
> TemplateMethodsTest::assertPreConditions
> TemplateMethodsTest::testTwo
> TemplateMethodsTest::tearDown
> TemplateMethodsTest::onNotSuccessfulTest
> FTemplateMethodsTest::tearDownAfterClass
> 
> Time: 0 seconds, Memory: 5.25Mb
> 
> There was 1 failure:
> 
> 1) TemplateMethodsTest::testTwo
> Failed asserting that <boolean:false> is true.
> /home/sb/TemplateMethodsTest.php:30
> 
> FAILURES!
> Tests: 2, Assertions: 2, Failures: 1.
> ```
>
> 
>
> ## setUp() 多、tearDown() 少
>
> 理论上说，`setUp()` 和 `tearDown()` 是精确对称的，但是实践中并非如此。实际上，只有在 `setUp()` 中分配了诸如文件或套接字之类的外部资源时才需要实现 `tearDown()` 。如果 `setUp()` 中只创建纯 PHP 对象，通常可以略过 `tearDown()`。不过，如果在 `setUp()` 中创建了大量对象，你可能想要在 `tearDown()` 中 `unset()` 指向这些对象的变量，这样它们就可以被垃圾回收机制回收掉。对测试用例对象的垃圾回收动作则是不可预知的。
>
> 
>
> ## 变体
>
> 如果拥有两个测试，它们的基境建立工作略有不同，该怎么办？有两种可能：
>
> - 如果两个 `setUp()` 代码仅有微小差异，把有差异的代码内容从 `setUp()` 移到测试方法内。
> - 如果两个 `setUp()` 是确实不一样，那么需要另外一个测试用例类。参考基境建立工作的不同之处来命名这个类。
>
> 
>
> ## 基境共享
>
> 有几个好的理由来在测试之间共享基境，但是大部分情况下，在测试之间共享基境的需求都源于某个未解决的设计问题。
>
> 一个有实际意义的多测试间共享基境的例子是数据库连接：只登录数据库一次，然后重用此连接，而不是每个测试都建立一个新的数据库连接。这样能加快测试的运行。
>
> [示例 4.3](https://phpunit.readthedocs.io/zh_CN/latest/fixtures.html#fixtures-sharing-fixture-examples-databasetest-php) 中用 `setUpBeforeClass()` 和 `tearDownAfterClass()` 模板方法来分别在测试用例类的第一个测试之前和最后一个测试之后连接与断开数据库。
>
> 示例 4.3 在同一个测试套件内的不同测试之间共享基境
>
> ```
> <?php declare(strict_types=1);
> use PHPUnit\Framework\TestCase;
> 
> final class DatabaseTest extends TestCase
> {
>     private static $dbh;
> 
>     public static function setUpBeforeClass(): void
>     {
>         self::$dbh = new PDO('sqlite::memory:');
>     }
> 
>     public static function tearDownAfterClass(): void
>     {
>         self::$dbh = null;
>     }
> }
> ```
>
> 需要反复强调的是：在测试之间共享基境会降低测试的价值。潜在的设计问题是对象之间并非松散耦合。如果解决掉潜在的设计问题并使用桩件（stub）（参见[测试替身](https://phpunit.readthedocs.io/zh_CN/latest/test-doubles.html#test-doubles)）来编写测试，就能达成更好的结果，而不是在测试之间产生运行时依赖并错过改进设计的机会。
>
> 
>
> ## 全局状态
>
> [使用单件（singleton）的代码很难测试。](http://googletesting.blogspot.com/2008/05/tott-using-dependancy-injection-to.html)使用全局变量的代码也一样。通常情况下，欲测代码和全局变量之间会强烈耦合，并且其创建无法控制。另外一个问题是，一个测试对全局变量的改变可能会破坏另外一个测试。
>
> 在 PHP 中，全局变量是这样运作的：
>
> - 全局变量 `$foo = 'bar';` 实际上是存储为 `$GLOBALS['foo'] = 'bar';` 的。
> - `$GLOBALS`这个变量是一种被称为*超全局*变量的变量。
> - 超全局变量是一种在任何变量作用域中都总是可用的内建变量。
> - 在函数或者方法的变量作用域中，要访问全局变量 `$foo`，可以直接访问 `$GLOBALS['foo']`，或者用 `global $foo;` 来创建一个引用全局变量的局部变量。
>
> 除了全局变量，类的静态属性也是一种全局状态。
>
> 在版本 6 之前，默认情况下，PHPUnit 用一种更改全局变量与超全局变量(`$GLOBALS`、`$_ENV`、`$_POST`、`$_GET`、`$_COOKIE`、`$_SERVER`、`$_FILES`、`$_REQUEST`)不会影响到其他测试的方式来运行所有测试。
>
> 在版本 6 中，默认情况下 PHPUnit 不再对全局变量和超全局变量进行这种备份与恢复的操作。可以用 `--globals-backup` 选项或在 XML 配置文件中用 `backupGlobals="true"` 将其激活。
>
> 通过用 `--static-backup` 选项或在 XML 配置文件中设置 `backupStaticAttributes="true"`，可以将此隔离扩展到类的静态属性。
>
> 注
>
> 对全局变量和类的静态属性的备份与还原操作使用了 `serialize()` 与 `unserialize()`。
>
> 某些类的实例对象（比如 `PDO`）无法序列化，因此如果把这样一个对象存放在比如说 `$GLOBALS` 数组内时，备份操作就会出问题。
>
> 在 [@backupGlobals](https://phpunit.readthedocs.io/zh_CN/latest/annotations.html#appendixes-annotations-backupglobals) 中所讨论的 `@backupGlobals` 标注可以用来控制对全局变量的备份与还原操作。另外，还可以提供一个全局变量的名单，名单中的全局变量将被排除于备份与还原操作之外，就像这样：
>
> ```
> final class MyTest extends TestCase
> {
>     protected $backupGlobalsExcludeList = ['globalVariable'];
> 
>     // ...
> }
> ```
>
> 注
>
> 在方法（例如 `setUp()` 方法）内对 `$backupGlobalsBlacklist` 属性进行设置是无效的。
>
> 在 [@backupStaticAttributes](https://phpunit.readthedocs.io/zh_CN/latest/annotations.html#appendixes-annotations-backupstaticattributes) 中提到的 `@backupStaticAttributes` 标注可以用于在每个测试之前备份所有已声明类的静态属性值并在其后恢复。
>
> 它所处理的并不只是测试类自身，而是在测试开始时已声明的所有类。它只作用于静态类属性，不作用于函数内声明的静态变量。
>
> 注
>
> 只有启用了 `@backupStaticAttributes` 的测试方法才会在方法之前执行此操作。如果在此之前运行的某个没有启用 `@backupStaticAttributes` 的测试方法改变了静态属性的值，那么被备份及还原的将会是这个改变后的值——而非初始声明时提供的默认值。PHP 并不额外记录任何静态变量的声明时提供的初始默认值。
>
> 同样的情况也发生于测试内部新加载/声明的类的静态属性上。它们也无法在测试结束之后复原为声明时提供的原始默认值，因为无从得知这些默认值。这些被修改过的值会泄漏到后继测试中。
>
> 对单元测试而言，推荐在 `setUp()` 中显式的重置测试中使用到的静态属性（最好同时在 `tearDown()` 中执行重置，这样就保证不会影响到后继的测试）。
>
> 可以提供名单来将静态属性从备份与还原操作中排除出去：
>
> ```
> final class MyTest extends TestCase
> {
>     protected $backupStaticAttributesExcludeList = [
>         'className' => ['attributeName']
>     ];
> 
>     // ...
> }
> ```
>
> 注
>
> 在方法（例如 `setUp()` 方法）内对 `$backupStaticAttributesExcludeList` 属性进行设置是无效的。



#### 组织测试/xml. 命令行 编排测试

- > PHPUnit 的目标之一是测试应当可组合：我们希望能将任意数量的测试以任意组合方式运行，例如，整个项目的所有测试，或者项目中的某个组件内的所有类的测试，又或者仅仅某单个类的测试。
  >
  > PHPUnit 支持好几种不同的方式来组织测试以及将它们编排组合成测试套件。本章介绍了最常用的方法。
  >
  > 
  >
  > ## 用文件系统来编排测试套件
  >
  > 编排测试套件的各种方式中，最简单的大概就是把所有测试用例源文件放在一个测试目录中。通过对测试目录进行递归遍历，PHPUnit 能自动发现并运行测试。
  >
  > 现在来看看 [sebastianbergmann/money](http://github.com/sebastianbergmann/money/) 这个库的测试套件。在这个项目的目录结构中，可以看到 `tests` 目录下的测试用例类镜像了 `src` 目录下被测系统（SUT，System Under Test）的包（package）与类（class）的结构：
  >
  > ```
  > src                                 tests
  > `-- Currency.php                    `-- CurrencyTest.php
  > `-- IntlFormatter.php               `-- IntlFormatterTest.php
  > `-- Money.php                       `-- MoneyTest.php
  > `-- autoload.php
  > ```
  >
  > 要运行这个库的全部测试，将 PHPUnit 命令行测试执行器指向测试目录：
  >
  > ```
  > $ phpunit --bootstrap src/autoload.php tests
  > PHPUnit latest.0 by Sebastian Bergmann and contributors.
  > 
  > .................................
  > 
  > Time: 636 ms, Memory: 3.50Mb
  > 
  > OK (33 tests, 52 assertions)
  > ```
  >
  > 注
  >
  > 当 PHPUnit 命令行测试执行器指向一个目录时，它会在目录下查找 `*Test.php` 文件。
  >
  > 如果只想运行在 `CurrencyTest` 文件中的 `tests/CurrencyTest.php` 测试用例类中声明的测试，可以使用如下命令：
  >
  > ```
  > $ phpunit --bootstrap src/autoload.php tests/CurrencyTest.php
  > PHPUnit latest.0 by Sebastian Bergmann and contributors.
  > 
  > ........
  > 
  > Time: 280 ms, Memory: 2.75Mb
  > 
  > OK (8 tests, 8 assertions)
  > ```
  >
  > 如果想要对运行哪些测试有更细粒度的控制，可以使用 `--filter` 选项：
  >
  > ```
  > $ phpunit --bootstrap src/autoload.php --filter testObjectCanBeConstructedForValidConstructorArgument tests
  > PHPUnit latest.0 by Sebastian Bergmann and contributors.
  > 
  > ..
  > 
  > Time: 167 ms, Memory: 3.00Mb
  > 
  > OK (2 test, 2 assertions)
  > ```
  >
  > 注
  >
  > 这种方法的缺点是无法控制测试的运行顺序。这可能导致测试的依赖关系方面的问题，参见[测试的依赖关系](https://phpunit.readthedocs.io/zh_CN/latest/writing-tests-for-phpunit.html#writing-tests-for-phpunit-test-dependencies)。在下一节中，可以看到如何用 XML 配置文件来明确指定测试的执行顺序。
  >
  > 
  >
  > ## 用 XML 配置来编排测试套件
  >
  > PHPUnit的 XML 配置文件（[XML 配置文件](https://phpunit.readthedocs.io/zh_CN/latest/configuration.html#appendixes-configuration)）也可以用于编排测试套件。[示例 5.1](https://phpunit.readthedocs.io/zh_CN/latest/organizing-tests.html#organizing-tests-xml-configuration-examples-phpunit-xml) 展示了一个最小化的 `phpunit.xml` 例子，它将在递归遍历 `tests` 时添加所有在 `*Test.php` 文件中找到的 `*Test` 类。
  >
  > 示例 5.1 用 XML 配置来编排测试套件
  >
  > ```
  > <phpunit bootstrap="src/autoload.php">
  >   <testsuites>
  >     <testsuite name="money">
  >       <directory>tests</directory>
  >     </testsuite>
  >   </testsuites>
  > </phpunit>
  > ```
  >
  > 要运行测试套件，用 `--testsuite` 选项：
  >
  > ```
  > $ phpunit --bootstrap src/autoload.php --testsuite money
  > PHPUnit latest.0 by Sebastian Bergmann and contributors.
  > 
  > ..
  > 
  > Time: 167 ms, Memory: 3.00Mb
  > 
  > OK (2 test, 2 assertions)
  > ```
  >
  > 如果 `phpunit.xml` 或 `phpunit.xml.dist`（按此顺序）存在于当前工作目录并且*未*使用 `--configuration`，将自动从此文件中读取配置。
  >
  > 可以明确指定测试的执行顺序：
  >
  > 示例 5.2 用 XML 配置来编排测试套件
  >
  > ```
  > <phpunit bootstrap="src/autoload.php">
  >   <testsuites>
  >     <testsuite name="money">
  >       <file>tests/IntlFormatterTest.php</file>
  >       <file>tests/MoneyTest.php</file>
  >       <file>tests/CurrencyTest.php</file>
  >     </testsuite>
  >   </testsuites>
  > </phpunit>
  > ```

#### 有风险测试

- > 在执行测试时，PHPUnit 可以进行一些额外的检查，见下文。
  >
  > 
  >
  > ## 无用测试
  >
  > 默认情况下，PHPUnit 会更严格地对待事实上不测试任何内容的测试。此项检查可以用[命令行](https://phpunit.readthedocs.io/zh_CN/latest/textui.html#textui-clioptions)选项 `--dont-report-useless-tests` 或在 PHPUnit 的[配置文件](https://phpunit.readthedocs.io/zh_CN/latest/configuration.html#appendixes-configuration)中设置 `beStrictAboutTestsThatDoNotTestAnything="false"` 来禁用。
  >
  > 在启用本项检查后，如果某个测试未进行任何断言，它将被标记为有风险。仿件对象中的预期同样视为断言。
  >
  > 
  >
  > ## 意外的代码覆盖
  >
  > PHPUnit 可以更严格对待意外的代码覆盖。此项检查可以用[命令行](https://phpunit.readthedocs.io/zh_CN/latest/textui.html#textui-clioptions)选项 `--strict-coverage` 或在 PHPUnit 的[配置文件](https://phpunit.readthedocs.io/zh_CN/latest/configuration.html#appendixes-configuration)中设置 `beStrictAboutCoversAnnotation="true"` 来启用。
  >
  > 在启用本项检查后，如果某个带有 [@covers](https://phpunit.readthedocs.io/zh_CN/latest/annotations.html#appendixes-annotations-covers) 标注的测试执行了未在 [@covers](https://phpunit.readthedocs.io/zh_CN/latest/annotations.html#appendixes-annotations-covers) 或 [@uses](https://phpunit.readthedocs.io/zh_CN/latest/annotations.html#appendixes-annotations-uses) 标注中列出的代码，它将被标记为有风险。
  >
  > 此外，通过在 PHPUnit 的[配置文件](https://phpunit.readthedocs.io/zh_CN/latest/configuration.html#appendixes-configuration)中设置 `forceCoversAnnotation="true"`，可以将没有 [@covers](https://phpunit.readthedocs.io/zh_CN/latest/annotations.html#appendixes-annotations-covers) 标注的测试标记为有风险。
  >
  > 
  >
  > ## 测试执行期间产生的输出
  >
  > PHPUnit 可以更严格对待测试执行期间产生的输出。 此项检查可以用[命令行](https://phpunit.readthedocs.io/zh_CN/latest/textui.html#textui-clioptions)选项 `--disallow-test-output` 或在 PHPUnit 的[配置文件](https://phpunit.readthedocs.io/zh_CN/latest/configuration.html#appendixes-configuration)中设置 `beStrictAboutOutputDuringTests="true"` 来启用。
  >
  > 在启用本项检查后，如果某个测试产生了输出，例如，在测试代码或被测代码中调用了 print，它将被标记为有风险。
  >
  > 
  >
  > ## 测试执行时长的超时限制
  >
  > 如果安装了 `PHP_Invoker` 包并且 `pcntl` 扩展可用，那么可以对测试的执行时长进行限制。此时间限制可以用[命令行](https://phpunit.readthedocs.io/zh_CN/latest/textui.html#textui-clioptions)选项 `--enforce-time-limit` 或在 PHPUnit 的[配置文件](https://phpunit.readthedocs.io/zh_CN/latest/configuration.html#appendixes-configuration)中设置 `enforceTimeLimit="true"` 来启用。
  >
  > 带有 `@large` 标注的测试如果执行时间超过 60 秒将视为失败。此超时限制可以通过[配置文件](https://phpunit.readthedocs.io/zh_CN/latest/configuration.html#appendixes-configuration)中的 `timeoutForLargeTests` 属性进行配置。
  >
  > 带有 `@medium` 标注的测试如果执行时间超过 10 秒将视为失败。此超时限制可以通过[配置文件](https://phpunit.readthedocs.io/zh_CN/latest/configuration.html#appendixes-configuration)中的 `timeoutForMediumTests` 属性进行配置。
  >
  > 带有 `@small` 标注的测试如果执行时间超过 1 秒将视为失败。此超时限制可以通过[配置文件](https://phpunit.readthedocs.io/zh_CN/latest/configuration.html#appendixes-configuration)中的 `timeoutForSmallTests` 属性进行配置。
  >
  > 注
  >
  > 需要启用运行时间限制的测试必须显式地标注为 `@small`、`@medium` 或 `@large`。
  >
  > 
  >
  > ## 全局状态篡改
  >
  > PHPUnit 可以更严格对待篡改全局状态的测试。此项检查可以用[命令行](https://phpunit.readthedocs.io/zh_CN/latest/textui.html#textui-clioptions)选项 `--strict-global-state` 或在 PHPUnit 的[配置文件](https://phpunit.readthedocs.io/zh_CN/latest/configuration.html#appendixes-configuration)中设置 `beStrictAboutChangesToGlobalState="true"` 来启用。



#### 未完成测试/跳过测试

- ```php
  <?php
  namespace framework\tests\test;
  
  use PHPUnit\Framework\TestCase;
  
  class SimpleTest extends TestCase
  {
      public function testNotCompelete()
      {
          $this->assertTrue(true);
  
          $this->markTestIncomplete('未完成');
      }
  
      public function testSkip()
      {
          $this->assertTrue(true);
          if (true) {
              $this->markTestSkipped('跳过测试');
          }
          $this->assertTrue(false);
      }
  
      /**
       * Undocumented function
       *
       * @requires OS WIN32|WINNT
       * @return void
       */
      public function testSkip2()
      {
          $this->assertTrue(false);
      }
  }
  ```

- > ## 未完成的测试
  >
  > 
  >
  > | 方法                                       | 含义                                                   |
  > | ------------------------------------------ | ------------------------------------------------------ |
  > | `void markTestIncomplete()`                | 将当前测试标记为未完成。                               |
  > | `void markTestIncomplete(string $message)` | 将当前测试标记为未完成，并用 `$message` 作为说明信息。 |
  >
  > ## 跳过测试
  >
  > | 方法                                    | 含义                                                   |
  > | --------------------------------------- | ------------------------------------------------------ |
  > | `void markTestSkipped()`                | 将当前测试标记为已跳过。                               |
  > | `void markTestSkipped(string $message)` | 将当前测试标记为已跳过，并用 `$message` 作为说明信息。 |
  >
  > ## 用 @requires 来跳过测试
  >
  > 除了上述方法，还可以用 `@requires` 标注来表达测试用例的一些常见前提条件。
  >
  > | 类型        | 可能值                                                       | 示例                         | 其他示例                                           |
  > | ----------- | ------------------------------------------------------------ | ---------------------------- | -------------------------------------------------- |
  > | `PHP`       | 任意 PHP 版本号以及可选的运算符                              | @requires PHP 7.1.20         | @requires PHP >= 7.2                               |
  > | `PHPUnit`   | 任意 PHPUnit 版本号以及可选的运算符                          | @requires PHPUnit 7.3.1      | @requires PHPUnit < 8                              |
  > | `OS`        | 与 [PHP_OS](https://www.php.net/manual/en/reserved.constants.php#constant.php-os) 匹配的正则表达式 | @requires OS Linux           | @requires OS WIN32\|WINNT                          |
  > | `OSFAMILY`  | 任意 [OS family](https://www.php.net/manual/en/reserved.constants.php#constant.php-os-family) | @requires OSFAMILY Solaris   | @requires OSFAMILY Windows                         |
  > | `function`  | 任意 [function_exists](https://www.php.net/function_exists) 的有效参数 | @requires function imap_open | @requires function ReflectionMethod::setAccessible |
  > | `extension` | 任意扩展名以及可选的版本号和可选的运算符                     | @requires extension mysqli   | @requires extension redis >= 2.2.0                 |
  >
  > PHP、PHPUnit 和扩展的版本约束支持以下运算符：`<`、`<=`、`>`、`>=`、`=`、`==`、`!=`、`<>`。如果使用了某种在特定版本的 PHP 下无法编译的语法，请参考[ 元素](https://phpunit.readthedocs.io/zh_CN/latest/configuration.html#appendixes-configuration-testsuites)中 XML 配置信息里关于版本依赖的部分。

#### xml配置

- <phpunit>

  - `cacheResult` （true）缓存结果位置
  - `convertDeprecationsToExceptions` (true) 转为异常
  - `convertErrorsToExceptions` (true) 转为异常
  - `convertNoticesToExceptions` (true)
  - ``convertWarningsToExceptions`` (true)
  -  
  - ``verbose`` （false） 是否打印详细输出

  - `backupGlobals` （false）是否还原备份的全局/超全局属性   `@backupGlobals`可覆盖
  - `backupStaticAttributes`  (false) 是否还原备份已声明的静态变量`@backupStaticAttributes` 可覆盖
  - `colors` (false) 输出彩色设置 true = --colors=auto ;false=never
  - ``processIsolation`` （false）是否单独进程测试
  - `stopOnError` (false) --- `stop...` (false)
  - 
  - `bootstrap` 引导脚本
  - `cacheResultFile`  测试缓存结果在哪个位置

- `<testsuites>` 测试套件 

  - 父元素 `<phpunit>`

- `<testsuite>` 测试套件 

  - 父元素 `<testsuites>`

  - > `<testsuite>` 元素必须拥有 `name` 属性，可以有一个或多个 `<directory>` 及 `<file>` 子元素，分别代表需要搜索测试的目录及元素。

  - 属性 `suffix=".php"` 以php后缀结尾的文件 

  - 属性 ` prefix=""` 前缀

  - 属性 `phpVersion` 属性版本

- `<directory>` 

  - 父元素 `<include>` `<exclude>` `<testsuite>`

- `<file> ` 

  - 父元素 `<include>` `<exclude>` `<testsuite>`

- `<exclude>` `<include>` 排除

   - 
   
- `<logging>` 执行期间日志报告

   - > ```xml
     > <logging>
     >   <log type="coverage-html" target="/tmp/report" lowUpperBound="35"
     >        highLowerBound="70"/>
     >   <log type="coverage-clover" target="/tmp/coverage.xml"/>
     >   <log type="coverage-php" target="/tmp/coverage.serialized"/>
     >   <log type="coverage-text" target="php://stdout" showUncoveredFiles="false"/>
     >   <log type="junit" target="/tmp/logfile.xml" logIncompleteSkipped="false"/>
     >   <log type="testdox-html" target="/tmp/testdox.html"/>
     >   <log type="testdox-text" target="/tmp/testdox.txt"/>
     > </logging>
     > ```

- `<php>` 配置常量 全局变量等的
  - 父元素 `<phpunit>`
  - 子元素 `<ini> 、<const>、<var>、<env>、 <get>、 <post>、<cookie>、<server> 、<files>、<request>`